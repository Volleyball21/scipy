# -*- coding: utf-8 -*-
"""SciPy_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JjtKUmI3eliCUWhmUHbeuKdOFJ3G2OXH

# **Analyzing music behaviour and predicting playlists**

Ideen:


*   three songs -> new ideas
*   load, preprocess data

*   streamlit app as input formular for extra criteria


  *   visualization and analysation
      *   features over the years (bmp, dancability, energy, valence, ...)
      *   bpm, dancability and valence (3D)
      * average length over the years (statistical analysis)
      *   bpm, dancability, liveness
      * distribution of key features (e.g., energy, danceability, acousticness) across different languages

* ML
  * clustering into genres (k means oder hierarchical clustering)
    * clustering using multiple audio features (using K-Means or Hierarchical Clustering) to identify different "types" of tracks that might not necessarily align with traditional genres
  * song prediction to 3 given songs (k nearest neighbors?)

Requirements to have installed:
 * kaggle
 * numpy  ?preinstalled
 * pandas ?preinstalled

# **Data description**
"""
import kagglehub
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import NearestNeighbors
import streamlit as st

# Download latest version
path = kagglehub.dataset_download("gauthamvijayaraj/spotify-tracks-dataset-updated-every-week")

print("Path to dataset files:", path)

# Load the dataset
df = pd.read_csv(path+'/spotify_tracks.csv')

# Display the first few rows
df.head()

"""# **Preprocessing of the data**"""

df = df.drop_duplicates(subset=['track_name','artist_name']) #deletes all row duplicates
df = df.drop(['liveness','artwork_url','mode'], axis = 1) #delete the columns liveness, artwork_url and mode
df = df[~(df == -1).any(axis=1)] #deletes all entries with values that are -1 (not existent)
df.head()

# substitute track-id values by numbers from 0 to len(dataframe)
df['track_id'] = range(len(df))
df.head()

# basic setup for streamlit
sp = StreamlitPatcher()
sp.jupyter()  # register patcher with streamlit

st.set_page_config(
    page_title="Playlist Prediction",
    page_icon="â™«"
)
# display title and short explanation
st.title("Welcome to our Playlist Prediction")
st.write("where you might discover your new favorite songs!")

"""# **Data analysis and visualization**

## 1) General data analysis
"""

df.describe()

"""Here we can analyse the data displayed above:
...
...
...
"""

#creating a histogram for song releases over the years
fig = plt.figure()
gs = fig.add_gridspec(2, 2)
ax1 = fig.add_subplot(gs[0, 0])
ax2 = fig.add_subplot(gs[1, 0])
ax3 = fig.add_subplot(gs[0, 1])
ax4 = fig.add_subplot(gs[1, 1])

ax1.hist(df['year'], bins = 50, color = "maroon", density = "True")
ax1.set_xlabel("year")
ax1.set_title("Song releases over the years")

ax2.hist(df['danceability'], bins ='auto', color = "#D2665A",density = "True")
ax2.set_xlabel("danceability")
ax2.set_title("Distribution of danceability")

ax3.hist(df['instrumentalness'], bins = 30, color = "#F2B28C",density = "True")
ax3.set_xlabel("instrumentalness")
ax3.set_title("Distribution of instrumentalness")

ax4.hist(df['duration_ms'], bins = 50, color = "#F6DED8",density = "True")
ax4.set_xlabel("song length in ms")
ax4.set_title("Distribution of song length")
fig.tight_layout()
plt.show()

"""From the plotted graphs, we are able to draw the following conclusions:

-the number of songs which were released each year increased over the last 50 years. Last year, the amount of released music was much higher than before.

-Most of the songs have a dancability score between 0.4 and 0.8

-Nearly all songs have a very low instrumentalness score and are rather short.

## 2) Exploration of cultural patterns and trends
"""



"""## 3) Correlation between features"""

fig, ax = plt.subplots()
ax.scatter(x=df["danceability"]*100,y=df["popularity"],alpha = 0.09, color = "#7C444F")
ax.set_xlabel("dancability in %")
ax.set_ylabel("popularity in %")
ax.set_title("Relation beween danceability and acousticness")
ax.grid(True)
fig.tight_layout()
plt.show()

"""As the plot displays, the most popular songs have a medium or high danceability.
Nevertheless, it is likely that the popularity does not only depend on the dancability.
"""



"""
#**Playlist prediction**"""

# contrast coding the language column
df['language'] = df['language'].astype('category')
df['language'] = df['language'].cat.codes
df.head()

# select relevant features for KNN
features = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness', 'instrumentalness', 'valence', 'tempo', 'language']
X = df[features].values

# Initialize and fit the KNN model
knn = NearestNeighbors(n_neighbors=13, algorithm='auto', metric='cosine')
knn.fit(X)

def recommend_songs(song_ids):
  """
  Recommends songs based on KNN.

  Args:
    song_ids: A list of IDs of the songs.
    k: Number of recommendations.

  Returns:
    A list of recommended song ids.
  """
  if not song_ids:
    return []

  # Find average feature vector for the input songs
  avg_features = np.mean(X[song_ids], axis=0)

  # Find k-nearest neighbors to this average vector
  distances, ids = knn.kneighbors([avg_features], n_neighbors=13)

  # Return recommended song indices (excluding the input songs)
  recommended_ids = [i for i in ids[0] if i not in song_ids]
  return recommended_ids

# Example usage: Recommend songs based on the first three songs
recommended_song_ids = recommend_songs([i for i in range(25528,25535)])

# Display recommended songs (song titles, or other relevant information)
if recommended_song_ids:
    print("Recommended song IDs:")
    for idx in recommended_song_ids:
        print(df['track_name'][idx])
else:
    print("No valid song indices provided or no recommendations found")

# prompt: interface where user can search for 3 songs (one at a time) from the dataset by the track name and then the predicted playlist is shown (track name, artist, year, album name)

import pandas as pd
import numpy as np
from sklearn.neighbors import NearestNeighbors

# Load the dataset (assuming 'df' is already loaded from the previous code)
# ... (Your data loading and preprocessing code from the previous response) ...

# Initialize and fit the KNN model (assuming 'knn' is already initialized and fitted)
# ... (Your KNN model initialization and fitting code from the previous response) ...


def recommend_songs(song_ids):
    """
    Recommends songs based on KNN.

    Args:
      song_ids: A list of IDs of the songs.

    Returns:
      A DataFrame of recommended songs.
    """

    if not song_ids:
        return pd.DataFrame()

    # Find average feature vector for the input songs
    avg_features = np.mean(X[song_ids], axis=0)

    # Find k-nearest neighbors to this average vector
    distances, ids = knn.kneighbors([avg_features], n_neighbors=13)

    # Return recommended song indices (excluding the input songs)
    recommended_ids = [i for i in ids[0] if i not in song_ids]
    recommended_songs = df.loc[recommended_ids, ['track_name', 'artist_name', 'year', 'album_name']]
    return recommended_songs


# Example usage in an interactive loop
for i in range(3):
    search_term = input(f"Enter the name of song {i+1}: ")
    matching_songs = df[df['track_name'].str.contains(search_term, case=False)]

    if matching_songs.empty:
        print("No matching songs found. Please try again.")
        continue

    print("Matching songs:")
    for index, row in matching_songs.iterrows():
        print(f"{index}: {row['track_name']} by {row['artist_name']}")

    while True:
        try:
            selected_song_index = int(input("Select the song by entering its index: "))
            if selected_song_index in matching_songs.index:
                break
            else:
                print("Invalid index. Please enter a valid index from the list above.")
        except ValueError:
            print("Invalid input. Please enter a number.")

    recommended_songs_df = recommend_songs([selected_song_index])

    if not recommended_songs_df.empty:
        print("\nRecommended Playlist:")
        print(recommended_songs_df)
    else:
        print("No recommendations found for this song.")

# streamlit app in jupyter



